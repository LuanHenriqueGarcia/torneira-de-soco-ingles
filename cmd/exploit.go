package cmd

import (
	"fmt"
	"strings"
	"time"
	"torneira-de-soco-ingles/internal"
	"torneira-de-soco-ingles/internal/payloads"

	"github.com/spf13/cobra"
)

var (
	exploitTarget  string
	exploitType    string
	exploitParam   string
	exploitMethod  string
	exploitData    string
	exploitHeaders []string
	exploitVerbose bool
	exploitAll     bool
)

var exploitCmd = &cobra.Command{
	Use:   "exploit",
	Short: "Testa vulnerabilidades conhecidas",
	Long: `Módulo de exploração para testar vulnerabilidades comuns.

Tipos de vulnerabilidades:
  - sqli:    SQL Injection
  - xss:     Cross-Site Scripting
  - lfi:     Local File Inclusion
  - rfi:     Remote File Inclusion
  - cmdi:    Command Injection
  - ssti:    Server-Side Template Injection
  - ssrf:    Server-Side Request Forgery
  - xxe:     XML External Entity

Exemplos:
  # Testar SQL Injection
  skynet exploit -t "http://target.com/page?id=1" --type sqli

  # Testar XSS em parâmetro específico
  skynet exploit -t "http://target.com/search" --type xss -p query

  # Testar todas as vulnerabilidades
  skynet exploit -t "http://target.com/page?id=1" --all`,
	Run: func(cmd *cobra.Command, args []string) {
		runExploit()
	},
}

func init() {
	exploitCmd.Flags().StringVarP(&exploitTarget, "target", "t", "", "URL alvo (obrigatório)")
	exploitCmd.Flags().StringVar(&exploitType, "type", "", "Tipo de vulnerabilidade: sqli, xss, lfi, cmdi, etc")
	exploitCmd.Flags().StringVarP(&exploitParam, "param", "p", "", "Parâmetro específico para testar")
	exploitCmd.Flags().StringVarP(&exploitMethod, "method", "m", "GET", "Método HTTP (GET, POST)")
	exploitCmd.Flags().StringVarP(&exploitData, "data", "d", "", "Dados POST")
	exploitCmd.Flags().StringArrayVarP(&exploitHeaders, "header", "H", nil, "Headers customizados")
	exploitCmd.Flags().BoolVarP(&exploitVerbose, "verbose", "v", false, "Modo verboso")
	exploitCmd.Flags().BoolVar(&exploitAll, "all", false, "Testar todas as vulnerabilidades")

	exploitCmd.MarkFlagRequired("target")

	rootCmd.AddCommand(exploitCmd)
}

type VulnResult struct {
	Type      string
	Payload   string
	Vulnerable bool
	Evidence  string
	URL       string
}

func runExploit() {
	internal.PrintBanner()
	internal.PrintInfo("Iniciando módulo de Exploit...")

	if exploitType == "" && !exploitAll {
		internal.PrintError("Especifique --type ou use --all para testar todas")
		internal.PrintInfo("Tipos disponíveis: %v", payloads.GetAvailablePayloadTypes())
		return
	}

	internal.PrintInfo("Target: %s", exploitTarget)
	internal.PrintInfo("Método: %s", exploitMethod)
	fmt.Println()

	client := internal.NewHTTPClient(15, true, "")

	for _, h := range exploitHeaders {
		parts := strings.SplitN(h, ":", 2)
		if len(parts) == 2 {
			client.SetHeader(strings.TrimSpace(parts[0]), strings.TrimSpace(parts[1]))
		}
	}

	var typesToTest []string
	if exploitAll {
		typesToTest = []string{"sqli", "xss", "lfi", "cmdi", "ssti"}
	} else {
		typesToTest = []string{exploitType}
	}

	var allResults []VulnResult

	for _, vulnType := range typesToTest {
		internal.PrintInfo("===============================================")
		internal.PrintInfo("  Testando: %s", strings.ToUpper(vulnType))
		internal.PrintInfo("===============================================")

		vulnPayloads := payloads.GetPayloadsByType(vulnType)
		if vulnPayloads == nil {
			internal.PrintWarning("Tipo de payload não encontrado: %s", vulnType)
			continue
		}

		results := testVulnerability(client, vulnType, vulnPayloads)
		allResults = append(allResults, results...)
	}

	fmt.Println()
	internal.PrintInfo("═══════════════════════════════════════════════")
	internal.PrintInfo("  RESUMO DO SCAN DE VULNERABILIDADES")
	internal.PrintInfo("═══════════════════════════════════════════════")

	vulnCount := 0
	for _, r := range allResults {
		if r.Vulnerable {
			vulnCount++
			internal.PrintSuccess("[VULNERÁVEL] %s", r.Type)
			internal.PrintInfo("  Payload: %s", truncatePayload(r.Payload, 60))
			if r.Evidence != "" {
				internal.PrintInfo("  Evidência: %s", truncatePayload(r.Evidence, 60))
			}
			fmt.Println()
		}
	}

	if vulnCount == 0 {
		internal.PrintWarning("Nenhuma vulnerabilidade detectada")
	} else {
		internal.PrintSuccess("Total de vulnerabilidades encontradas: %d", vulnCount)
	}
}

func testVulnerability(client *internal.HTTPClient, vulnType string, vulnPayloads []string) []VulnResult {
	var results []VulnResult

	baseResp, err := client.Get(exploitTarget)
	if err != nil {
		internal.PrintError("Erro ao conectar: %v", err)
		return results
	}
	baseSize := len(baseResp.Body)
	baseStatus := baseResp.StatusCode

	for i, payload := range vulnPayloads {
		if exploitVerbose {
			fmt.Printf("\r[*] Testando payload %d/%d", i+1, len(vulnPayloads))
		}

		var targetURL string
		var resp *internal.HTTPResponse

		if exploitParam != "" {
			if strings.Contains(exploitTarget, "?") {
				targetURL = fmt.Sprintf("%s&%s=%s", exploitTarget, exploitParam, payload)
			} else {
				targetURL = fmt.Sprintf("%s?%s=%s", exploitTarget, exploitParam, payload)
			}
		} else if strings.Contains(exploitTarget, "=") {
			idx := strings.LastIndex(exploitTarget, "=")
			targetURL = exploitTarget[:idx+1] + payload
		} else {
			targetURL = exploitTarget + payload
		}

		if exploitMethod == "POST" && exploitData != "" {
			data := exploitData
			if strings.Contains(data, "FUZZ") {
				data = strings.ReplaceAll(data, "FUZZ", payload)
			}
			resp, err = client.Post(targetURL, data)
		} else {
			resp, err = client.Get(targetURL)
		}

		if err != nil {
			continue
		}

		vulnerable, evidence := detectVulnerability(vulnType, payload, resp, baseSize, baseStatus)

		if vulnerable {
			result := VulnResult{
				Type:       vulnType,
				Payload:    payload,
				Vulnerable: true,
				Evidence:   evidence,
				URL:        targetURL,
			}
			results = append(results, result)

			fmt.Println()
			internal.PrintSuccess("Potencial %s detectado!", strings.ToUpper(vulnType))
			internal.PrintInfo("  Payload: %s", truncatePayload(payload, 50))
			internal.PrintInfo("  Status: %d | Size: %d", resp.StatusCode, len(resp.Body))
			if evidence != "" {
				internal.PrintInfo("  Evidência: %s", evidence)
			}

			break
		}

		time.Sleep(100 * time.Millisecond)
	}

	if exploitVerbose {
		fmt.Println()
	}

	return results
}

func detectVulnerability(vulnType, payload string, resp *internal.HTTPResponse, baseSize, baseStatus int) (bool, string) {
	body := strings.ToLower(resp.Body)

	switch vulnType {
	case "sqli":
		sqlErrors := []string{
			"sql syntax", "mysql", "sqlite", "postgresql", "oracle",
			"microsoft sql", "odbc", "syntax error", "unclosed quotation",
			"you have an error in your sql", "warning: mysql",
			"valid mysql result", "supplied argument is not a valid mysql",
			"pg_query()", "pg_exec()", "ora-", "db2_", "sqlite3",
		}
		for _, err := range sqlErrors {
			if strings.Contains(body, err) {
				return true, fmt.Sprintf("SQL Error: '%s'", err)
			}
		}

		if strings.Contains(payload, "1=1") || strings.Contains(payload, "1'='1") {
			sizeDiff := len(resp.Body) - baseSize
			if sizeDiff > 100 || sizeDiff < -100 {
				return true, fmt.Sprintf("Size difference: %d bytes", sizeDiff)
			}
		}

	case "xss":
		if strings.Contains(resp.Body, payload) {
			return true, "Payload refletido na resposta"
		}
		if strings.Contains(body, "<script>alert") || strings.Contains(body, "onerror=") {
			return true, "Script tag ou event handler detectado"
		}

	case "lfi":
		lfiIndicators := []string{
			"root:x:", "daemon:x:", "[boot loader]", "[fonts]",
			"for 16-bit app support", "<?php", "<%", "#!/bin/",
		}
		for _, indicator := range lfiIndicators {
			if strings.Contains(body, strings.ToLower(indicator)) {
				return true, fmt.Sprintf("File content detected: '%s'", indicator)
			}
		}

	case "cmdi":
		cmdIndicators := []string{
			"uid=", "gid=", "groups=", "total ", "drwx", "-rw-",
			"volume serial number", "directory of", "windows\\system32",
		}
		for _, indicator := range cmdIndicators {
			if strings.Contains(body, strings.ToLower(indicator)) {
				return true, fmt.Sprintf("Command output: '%s'", indicator)
			}
		}

	case "ssti":
		if strings.Contains(payload, "7*7") && strings.Contains(resp.Body, "49") {
			return true, "Expression evaluated: 7*7=49"
		}
		if strings.Contains(body, "config") && strings.Contains(payload, "config") {
			return true, "Config object exposed"
		}

	case "ssrf":
		if resp.Duration > 5*time.Second {
			return true, fmt.Sprintf("Response time: %v", resp.Duration)
		}

	case "xxe":
		if strings.Contains(body, "root:") || strings.Contains(body, "[fonts]") {
			return true, "XXE file read detected"
		}
	}

	return false, ""
}

func truncatePayload(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen-3] + "..."
}
